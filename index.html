<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Бот в Лабиринте | API Управляемая Симуляция</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap');
        @import url("https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css");

        :root {
            --bg-color: #1a1a2e;
            --panel-bg: rgba(28, 28, 65, 0.88);
            --panel-border: rgba(120, 120, 180, 0.4);
            --text-color: #e8e8ff;
            --text-muted: #a0a0cc;
            --accent-color: #c0c0ff;
            --accent-gradient-start: #6a6aac;
            --accent-gradient-end: #5a5aa8;
            --accent-gradient-hover-start: #7a7abc;
            --accent-gradient-hover-end: #6a6aa8;
            --accent-gradient-active-start: #5a5a88;
            --accent-gradient-active-end: #4a4a77;
            --button-shadow: rgba(0, 0, 0, 0.3);
            --button-border: #4a4a77;
            --status-init: #87CEFA;
            --status-nav: #98FB98;
            --status-solved: #FFD700;
            --status-error: #FF6347;
            --api-idle: var(--text-muted);
            --api-request: #FFC107;
            --api-received: #AFEEEE;
            --api-error: #FFA07A;
            --debug-border: #6c5ce7;
            --debug-text: #cccccc;
            --debug-label: #a29bfe;
            --viewport-border: rgba(255, 255, 255, 0.15);
            --compass-needle-color: #e63946;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        body {
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto', sans-serif;
            font-size: 16px;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .hud-panel {
            position: absolute;
            background-color: var(--panel-bg);
            padding: 15px;
            border-radius: 12px;
            z-index: 10;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.45);
            border: 1px solid var(--panel-border);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            box-sizing: border-box;
        }

        #info {
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 550px;
            width: calc(100% - 40px);
            height: 250px;
        }

        #info h2 {
            font-family: 'Orbitron', sans-serif;
            margin: 0 0 10px 0;
            padding-bottom: 12px;
            font-size: 1.5em;
            color: var(--accent-color);
            border-bottom: 2px solid var(--panel-border);
            text-align: center;
            letter-spacing: 1.5px;
            text-shadow: 0 0 5px rgba(192, 192, 255, 0.3);
        }

        #info .status-label {
            font-size: 0.95em;
            color: var(--text-muted);
            margin-bottom: 5px;
            display: block;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #info .status-label::before {
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            margin-right: 8px;
            color: var(--accent-color);
            opacity: 0.7;
        }

        #info .status-label[for="status"]::before {
            content: "\f085";
        }

        #info .status-label[for="api-status"]::before {
            content: "\f3c2";
        }

        #status,
        #api-status {
            margin-bottom: 20px;
            font-weight: bold;
            font-size: 1.1em;
            min-height: 1.5em;
            line-height: 1.5em;
            text-align: center;
            padding: 8px 12px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.25);
            transition: all 0.4s ease;
            border: 1px solid transparent;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        #status.initializing {
            color: var(--status-init);
            border-color: var(--status-init);
            background-color: rgba(135, 206, 250, 0.1);
        }

        #status.navigating {
            color: var(--status-nav);
            border-color: var(--status-nav);
            background-color: rgba(152, 251, 152, 0.1);
        }

        #status.solved {
            color: var(--status-solved);
            border-color: var(--status-solved);
            background-color: rgba(255, 215, 0, 0.15);
        }

        #status.error {
            color: var(--status-error);
            border-color: var(--status-error);
            background-color: rgba(255, 99, 71, 0.15);
        }

        #api-status.idle {
            color: var(--api-idle);
            border-color: rgba(160, 160, 204, 0.3);
        }

        #api-status.requesting {
            color: var(--api-request);
            border-color: var(--api-request);
            background-color: rgba(255, 193, 7, 0.1);
        }

        #api-status.received {
            color: var(--api-received);
            border-color: var(--api-received);
            background-color: rgba(175, 238, 238, 0.1);
        }

        #api-status.error {
            color: var(--api-error);
            border-color: var(--api-error);
            background-color: rgba(255, 160, 122, 0.15);
        }

        #reset-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: auto;
            background: linear-gradient(145deg, var(--accent-gradient-start), var(--accent-gradient-end));
            color: #ffffff;
            border: none;
            padding: 14px 18px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            transition: all 0.25s ease;
            box-shadow: 0 4px 8px var(--button-shadow);
            border-bottom: 3px solid var(--button-border);
            text-transform: uppercase;
        }

        #reset-button::before {
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            content: "\f021";
        }

        #reset-button:hover {
            background: linear-gradient(145deg, var(--accent-gradient-hover-start), var(--accent-gradient-hover-end));
            box-shadow: 0 6px 12px var(--button-shadow);
            transform: translateY(-2px);
        }

        #reset-button:active {
            background: linear-gradient(145deg, var(--accent-gradient-active-start), var(--accent-gradient-active-end));
            box-shadow: 0 2px 5px var(--button-shadow);
            transform: translateY(1px);
            border-bottom-width: 2px;
        }

        #compass {
            top: 15px;
            left: 15px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            z-index: 12;
        }

        #compass::before {
            content: 'N';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: var(--text-muted);
            font-weight: bold;
        }

        #compass-needle {
            font-size: 28px;
            color: var(--compass-needle-color);
            transform-origin: center center;
            transition: transform 0.1s linear;
        }

        #debug-info {
            position: relative;
            top: auto;
            left: auto;
            background-color: var(--panel-bg);
            padding: 18px 25px;
            border-radius: 15px;
            font-size: 1em;
            min-width: 280px;
            max-width: 320px;
            width: auto;
            font-family: 'Roboto', sans-serif;
            color: var(--text-color);
            border: 1px solid var(--panel-border);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-sizing: border-box;
            pointer-events: auto;
        }

        #top-left-hud-wrapper {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            align-items: flex-start;
            gap: 15px;
            z-index: 11;
            pointer-events: none;
        }

        #compass-hud {
            position: relative;
            top: auto;
            left: auto;
            pointer-events: auto;
            width: 100px;
            height: 100px;
            padding: 0;
            border-radius: 50%;
            background: radial-gradient(circle, #3a3a5e 0%, var(--panel-bg) 70%);
            border: 2px solid var(--accent-gradient-start);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #compass-rose {
            position: absolute;
            width: 90%;
            height: 90%;
            top: 5%;
            left: 5%;
            background-image:
                linear-gradient(to bottom, var(--text-muted) 2px, transparent 2px),
                linear-gradient(to top, var(--text-muted) 2px, transparent 2px),
                linear-gradient(to left, var(--text-muted) 2px, transparent 2px),
                linear-gradient(to right, var(--text-muted) 2px, transparent 2px),
                linear-gradient(to bottom right, var(--text-muted) 1px, transparent 1px),
                linear-gradient(to bottom left, var(--text-muted) 1px, transparent 1px),
                linear-gradient(to top right, var(--text-muted) 1px, transparent 1px),
                linear-gradient(to top left, var(--text-muted) 1px, transparent 1px);

            background-size: 100% 8px, 100% 8px, 8px 100%, 8px 100%,
                15px 15px, 15px 15px, 15px 15px, 15px 15px;

            background-repeat: no-repeat, no-repeat, no-repeat, no-repeat,
                no-repeat, no-repeat, no-repeat, no-repeat;

            background-position: center top, center bottom, right center, left center,
                top right, top left, bottom right, bottom left;

            opacity: 0.5;
            border-radius: 50%;
            transform: rotate(45deg);
        }

        #compass-hud .cardinal {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-color);
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.6);
            z-index: 1;
        }

        #compass-hud .north {
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
        }

        #compass-hud .south {
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
        }

        #compass-hud .east {
            top: 50%;
            right: 5px;
            transform: translateY(-50%);
        }

        #compass-hud .west {
            top: 50%;
            left: 5px;
            transform: translateY(-50%);
        }

        #compass-needle {
            width: 0;
            height: 0;
            border-left: 7px solid transparent;
            border-right: 7px solid transparent;
            border-bottom: 40px solid var(--compass-needle-color);
            position: relative;
            z-index: 2;
            transform-origin: 50% 60%;
            transition: transform 0.15s linear;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.6));
        }

        #compass-needle::after {
            content: '';
            position: absolute;
            bottom: -47px;
            left: -7px;
            width: 0;
            height: 0;
            border-left: 7px solid transparent;
            border-right: 7px solid transparent;
            border-top: 12px solid #bbbbcc;
            transform-origin: 50% 0%;
        }

        #debug-info strong {
            color: var(--accent-color);
            font-weight: bold;
            display: block;
            margin-bottom: 8px;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #debug-info span {
            display: block;
            margin-bottom: 5px;
            line-height: 1.6;
        }

        #debug-info .separator {
            color: var(--text-muted);
            margin: 0 8px;
        }

        #debug-info br {
            display: none;
        }

        #debug-info span#sensor-values {
            margin-bottom: 10px;
        }

        #top-right-controls-wrapper {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 11;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 15px;
        }

        #top-right-controls-wrapper .hud-panel {
            position: relative;
            top: auto;
            right: auto;
            z-index: auto;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            background-color: var(--panel-bg);
            border: 1px solid var(--panel-border);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.45);
        }

        #new-maze-panel {
            display: flex;
            justify-content: center;
            padding: 10px;
        }

        #camera-controls {
            display: flex;
            gap: 12px;
            padding: 15px;
        }

        #camera-controls button {
            background: linear-gradient(145deg, var(--accent-gradient-start), var(--accent-gradient-end));
            color: #ffffff;
            border: none;
            padding: 12px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 3px 6px var(--button-shadow);
            border-bottom: 3px solid var(--button-border);
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        #camera-controls button:hover {
            background: linear-gradient(145deg, var(--accent-gradient-hover-start), var(--accent-gradient-hover-end));
            box-shadow: 0 4px 8px var(--button-shadow);
            transform: translateY(-2px);
        }

        #camera-controls button:active,
        #camera-controls button.active {
            background: linear-gradient(145deg, var(--accent-gradient-active-start), var(--accent-gradient-active-end));
            box-shadow: 0 1px 3px var(--button-shadow);
            transform: translateY(1px);
            border-bottom-width: 2px;
            font-weight: 700;
        }

        #camera-controls button i {
            margin-right: 0;
            width: auto;
            font-size: 1.1em;
        }
    </style>
</head>

<body>
    <div id="info" class="hud-panel">
        <h2>УПРАВЛЕНИЕ РОБОТОМ</h2>

        <span class="status-label" for="status">Статус Системы:</span>
        <div id="status" class="initializing">Инициализация...</div>

        <span class="status-label" for="api-status">Связь с API:</span>
        <div id="api-status" class="idle">API: Ожидание</div>
    </div>

    <div id="top-left-hud-wrapper">
        <div id="debug-info" class="hud-panel">
            <strong>Датчики:</strong>
            <span id="sensor-values">Ф: Н/Д<span class="separator">|</span>Л: Н/Д<span class="separator">|</span>П:
                Н/Д</span>
        </div>
        <div id="compass-hud" class="hud-panel">
            <div id="compass-rose"></div>
            <div class="cardinal north">N</div>
            <div class="cardinal south">S</div>
            <div class="cardinal east">E</div>
            <div class="cardinal west">W</div>
            <div id="compass-needle"></div>
        </div>
    </div>

    <div id="top-right-controls-wrapper">
        <div id="new-maze-panel" class="hud-panel">
            <button id="reset-button">Новый Лабиринт</button>
        </div>
        <div id="camera-controls" class="hud-panel">
            <button id="btn-main-cam"><i class="fas fa-satellite-dish"></i>Обзор</button>
            <button id="btn-fp-cam"><i class="fas fa-robot"></i>От робота</button>
            <button id="btn-free-cam"><i class="fas fa-dove"></i>Свободная</button>
        </div>
    </div>

    <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
                }
            }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FlyControls } from 'three/addons/controls/FlyControls.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const translations = {
            statusInitializing: "Инициализация...",
            statusNavigating: "Прохождение лабиринта...",
            statusSolved: "Лабиринт пройден!",
            statusError: "Ошибка системы!",
            apiIdle: "API: Ожидание",
            apiRequesting: "API: Запрос...",
            apiReceived: "API: Получено ",
            apiError: "API Ошибка: ",
            apiComplete: "API: Задача выполнена",
            debugSensorsLabel: "Датчики:",
            debugSensorPrefixF: "Ф:",
            debugSensorPrefixL: "Л:",
            debugSensorPrefixR: "П:",
            debugActionNone: "Нет",
            debugActionTurning: "Поворот",
            debugActionWaitingAPI: "Ожидание API",
            debugActionDeciding: "Решение...",
            debugActionMoving: "Движение",
            debugActionError: "Ошибка API",
            debugNA: "Н/Д",
            debugInfinity: "Беск.",
            apiActionForward: "FORWARD",
            apiActionLeft: "LEFT",
            apiActionRight: "RIGHT",
            uiActionForward: "ВПЕРЕД",
            uiActionLeft: "НАЛЕВО",
            uiActionRight: "НАПРАВО",
        };
        let scene, mainCamera, topDownCamera, firstPersonCamera, freeCamera, renderer, robotGroup, controls, fpControls, flyControls, compassRoseElement;
        let activeCameraType = 'main';
        let btnMainCam, btnFpCam, btnFreeCam;
        const clock = new THREE.Clock();

        const mazeWidth = 11;
        const mazeHeight = 11;
        const cellSize = 5;
        const wallHeight = 4;
        const wallThickness = 0.5;
        let mazeGrid = [];
        let mazeWallsGroup = new THREE.Group();
        let decorationGroup = new THREE.Group();
        let exitMarker = null;

        const moveSpeed = 2.5;
        const turnSpeed = Math.PI * 1.0;
        let targetRotation = 0;
        let needsRotation = false;
        let isMoving = true;

        const navigationRaycaster = new THREE.Raycaster();
        const sensorDistance = cellSize * 1.5;
        const collisionThreshold = cellSize * 0.3;
        let frontSensorDist = Infinity;
        let leftSensorDist = Infinity;
        let rightSensorDist = Infinity;
        let debugInfoElement;
        let statusElement;
        let apiStatusElement;
        let actionElement;
        let compassNeedleElement;

        let needsDecision = true;
        let isWaitingForAPI = false;
        let lastAPIAction = null;
        const API_CALL_INTERVAL = 5;
        let timeSinceLastAPICall = API_CALL_INTERVAL;

        let obstacles = [];

        const crateMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8, metalness: 0.1 });
        const barrelMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7, roughness: 0.4 });
        const crystalMat = new THREE.MeshStandardMaterial({ color: 0x40E0D0, transparent: true, opacity: 0.8, roughness: 0.2, metalness: 0.3, emissive: 0x11aaaa, emissiveIntensity: 0.3 });
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9, metalness: 0.0 });
        const pipeMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.5 });

        let mainViewport, topLeftViewport, topRightViewport;
        const insetMargin = 10;
        const insetSizeRatio = 0.2;

        const cameraForwardVector = new THREE.Vector3();

        function init() {
            debugInfoElement = document.getElementById('debug-info');
            statusElement = document.getElementById('status');
            apiStatusElement = document.getElementById('api-status');
            compassNeedleElement = document.getElementById('compass-needle');
            compassRoseElement = document.getElementById('compass-rose');

            scene = new THREE.Scene();
            const backgroundColor = 0x454a59;
            scene.background = new THREE.Color(backgroundColor);
            scene.fog = new THREE.Fog(backgroundColor, cellSize * mazeWidth * 0.6, cellSize * mazeWidth * 2.0);

            mainCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            mainCamera.position.set(cellSize * mazeWidth / 2, cellSize * mazeWidth * 0.9, cellSize * mazeHeight * 1.1);
            mainCamera.lookAt(cellSize * mazeWidth / 2, 0, cellSize * mazeHeight / 2);

            const aspect = window.innerWidth / window.innerHeight;
            const orthoSize = Math.max(mazeWidth, mazeHeight) * cellSize * 0.6;

            topDownCamera = new THREE.OrthographicCamera(
                -orthoSize * aspect, orthoSize * aspect, orthoSize, -orthoSize,
                1,
                2000
            );
            topDownCamera.position.set(cellSize * (mazeWidth - 1) / 2, 150, cellSize * (mazeHeight - 1) / 2);
            topDownCamera.rotation.order = 'YXZ';
            topDownCamera.rotation.x = -Math.PI / 2;
            topDownCamera.rotation.y = 0;
            topDownCamera.rotation.z = 0;
            topDownCamera.updateProjectionMatrix();

            firstPersonCamera = new THREE.PerspectiveCamera(80, aspect, 0.1, 50);

            freeCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            freeCamera.position.set(cellSize * mazeWidth / 2, cellSize * 2, cellSize * mazeHeight * 1.2);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.9;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(cellSize * mazeWidth / 3, 50, cellSize * mazeHeight / 3);
            directionalLight.target.position.set(cellSize * mazeWidth / 2, 0, cellSize * mazeHeight / 2);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            const shadowCamSize = Math.max(mazeWidth, mazeHeight) * cellSize * 0.7;
            directionalLight.shadow.camera.near = 10;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -shadowCamSize;
            directionalLight.shadow.camera.right = shadowCamSize;
            directionalLight.shadow.camera.top = shadowCamSize;
            directionalLight.shadow.camera.bottom = -shadowCamSize;
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            controls = new OrbitControls(mainCamera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.target.set(cellSize * mazeWidth / 2, 0, cellSize * mazeHeight / 2);
            controls.minDistance = cellSize * 2;
            controls.maxDistance = cellSize * mazeWidth * 1.5;

            flyControls = new FlyControls(freeCamera, renderer.domElement);
            flyControls.movementSpeed = 20;
            flyControls.rollSpeed = Math.PI / 4;
            flyControls.autoForward = false;
            flyControls.dragToLook = true;

            fpControls = new PointerLockControls(firstPersonCamera, document.body);
            fpControls.addEventListener('lock', function () { });
            fpControls.addEventListener('unlock', function () {
                if (activeCameraType === 'firstPerson') {
                    setActiveCamera('main');
                }
            });

            const textureLoader = new THREE.TextureLoader();
            const grassTextureUrl = 'http://livelab.spb.ru/labs/files/trava.jpg';
            const grassTexture = textureLoader.load(grassTextureUrl);

            grassTexture.wrapS = THREE.RepeatWrapping;
            grassTexture.wrapT = THREE.RepeatWrapping;
            grassTexture.repeat.set(mazeWidth, mazeHeight);

            const groundGeo = new THREE.PlaneGeometry(cellSize * mazeWidth, cellSize * mazeHeight);
            const groundMat = new THREE.MeshStandardMaterial({
                map: grassTexture,
                roughness: 0.95,
                metalness: 0.05
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(cellSize * mazeWidth / 2 - cellSize / 2, 0, cellSize * mazeHeight / 2 - cellSize / 2);
            ground.receiveShadow = true;
            scene.add(ground);

            robotGroup = createBeautifulRobot();
            const robotScale = cellSize * 0.08;
            robotGroup.scale.set(robotScale, robotScale, robotScale);

            robotGroup.add(fpControls.getObject());
            fpControls.getObject().rotation.y = Math.PI;
            firstPersonCamera.position.set(0, 5.5, 1.5);

            scene.add(robotGroup);

            scene.add(decorationGroup);

            btnMainCam = document.getElementById('btn-main-cam');
            btnFpCam = document.getElementById('btn-fp-cam');
            btnFreeCam = document.getElementById('btn-free-cam');

            btnMainCam.addEventListener('click', (event) => {
                event.preventDefault();
                setActiveCamera('main');
            });
            btnFpCam.addEventListener('click', (event) => {
                event.preventDefault();
                setActiveCamera('firstPerson');
            });

            btnFreeCam.addEventListener('click', (event) => {
                event.preventDefault();
                setActiveCamera('free');
            });

            renderer.domElement.addEventListener('click', () => {
                if (activeCameraType === 'firstPerson' && !fpControls.isLocked) {
                    fpControls.lock();
                }
            });

            setupNewMaze();
            setActiveCamera(activeCameraType);
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('reset-button').addEventListener('click', function (event) {
                event.preventDefault();
                setupNewMaze();
            });

            animate();
        }

        function setActiveCamera(cameraType) {
            activeCameraType = cameraType;

            btnMainCam.classList.toggle('active', cameraType === 'main');
            btnFpCam.classList.toggle('active', cameraType === 'firstPerson');
            btnFreeCam.classList.toggle('active', cameraType === 'free');

            controls.enabled = (cameraType === 'main');

            flyControls.enabled = (cameraType === 'free');
            if (!flyControls.enabled) {
                flyControls.moveState.up = 0; flyControls.moveState.down = 0; flyControls.moveState.left = 0; flyControls.moveState.right = 0; flyControls.moveState.forward = 0; flyControls.moveState.back = 0; flyControls.moveState.pitchUp = 0; flyControls.moveState.pitchDown = 0; flyControls.moveState.yawLeft = 0; flyControls.moveState.yawRight = 0; flyControls.moveState.rollLeft = 0; flyControls.moveState.rollRight = 0;
            }

            if (cameraType !== 'firstPerson') {
                if (fpControls.isLocked) {
                    fpControls.unlock();
                }
            }

            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = width / height;

            mainCamera.aspect = aspect;
            mainCamera.updateProjectionMatrix();

            firstPersonCamera.aspect = aspect;
            firstPersonCamera.updateProjectionMatrix();

            freeCamera.aspect = aspect;
            freeCamera.updateProjectionMatrix();

            const orthoSize = Math.max(mazeWidth, mazeHeight) * cellSize * 0.6;
            topDownCamera.left = -orthoSize * aspect;
            topDownCamera.right = orthoSize * aspect;
            topDownCamera.top = orthoSize;
            topDownCamera.bottom = -orthoSize;
            topDownCamera.updateProjectionMatrix();
        }

        function generateMaze(width, height) {
            let grid = Array(height).fill(null).map(() => Array(width).fill(null).map(() => ({
                visited: false,
                walls: { N: true, S: true, E: true, W: true }
            })));

            let stack = [];
            let currentX = 0;
            let currentY = 0;
            grid[currentY][currentX].visited = true;
            let visitedCells = 1;
            const totalCells = width * height;

            function getNeighbors(x, y) {
                const neighbors = [];
                if (y > 0 && !grid[y - 1][x].visited) neighbors.push({ x: x, y: y - 1, dir: 'N' });
                if (y < height - 1 && !grid[y + 1][x].visited) neighbors.push({ x: x, y: y + 1, dir: 'S' });
                if (x < width - 1 && !grid[y][x + 1].visited) neighbors.push({ x: x + 1, y: y, dir: 'E' });
                if (x > 0 && !grid[y][x - 1].visited) neighbors.push({ x: x - 1, y: y, dir: 'W' });
                return neighbors;
            }

            while (visitedCells < totalCells) {
                const neighbors = getNeighbors(currentX, currentY);

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];

                    if (next.dir === 'N') { grid[currentY][currentX].walls.N = false; grid[next.y][next.x].walls.S = false; }
                    if (next.dir === 'S') { grid[currentY][currentX].walls.S = false; grid[next.y][next.x].walls.N = false; }
                    if (next.dir === 'E') { grid[currentY][currentX].walls.E = false; grid[next.y][next.x].walls.W = false; }
                    if (next.dir === 'W') { grid[currentY][currentX].walls.W = false; grid[next.y][next.x].walls.E = false; }

                    stack.push({ x: currentX, y: currentY });
                    currentX = next.x;
                    currentY = next.y;
                    grid[currentY][currentX].visited = true;
                    visitedCells++;
                } else if (stack.length > 0) {
                    const prev = stack.pop();
                    currentX = prev.x;
                    currentY = prev.y;
                } else {

                    break;
                }
            }
            grid[0][0].walls.W = false;
            grid[height - 1][width - 1].walls.E = false;

            return grid;
        }

        function createMazeGeometry(grid, cellW, cellH, wallH, wallT) {
            const mazeGroup = new THREE.Group();
            obstacles = [];

            const textureLoader = new THREE.TextureLoader();
            const wallTextureUrl = 'http://livelab.spb.ru/labs/files/facade_bricks.jpg';
            const colorTexture = textureLoader.load(wallTextureUrl);

            const textureScaleFactor = 0.5;

            if (colorTexture) {
                colorTexture.wrapS = THREE.RepeatWrapping;
                colorTexture.wrapT = THREE.RepeatWrapping;
            }

            const baseWallMat = new THREE.MeshStandardMaterial({
                map: colorTexture,
                color: 0xcccccc,
                metalness: 0.0,
                roughness: 0.85,
            });

            const wallGeoHorizontal = new THREE.BoxGeometry(cellW, wallH, wallT);
            const wallGeoVertical = new THREE.BoxGeometry(wallT, wallH, cellH);

            const rows = grid.length;
            const cols = grid[0].length;
            const halfWallT = wallT / 2.0;

            const createWall = (geometry, position, isHorizontal) => {
                const matInstance = baseWallMat.clone();

                const repeatU = Math.max(1e-6, (isHorizontal ? cellW : cellH) * textureScaleFactor);
                const repeatV = Math.max(1e-6, wallH * textureScaleFactor);

                if (matInstance.map) {
                    matInstance.map = matInstance.map.clone();
                    matInstance.map.needsUpdate = true;
                    matInstance.map.repeat.set(repeatU, repeatV);
                }

                const wall = new THREE.Mesh(geometry, matInstance);
                wall.position.copy(position);
                wall.geometry.computeVertexNormals();
                wall.castShadow = true;
                wall.receiveShadow = true;
                mazeGroup.add(wall);
                obstacles.push(wall);
            };

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const cell = grid[y][x];
                    const cellCenterX = x * cellW;
                    const cellCenterZ = y * cellH;

                    if (cell.walls.N) {
                        const wallPosition = new THREE.Vector3(
                            cellCenterX,
                            wallH / 2,
                            cellCenterZ - cellH / 2 + halfWallT
                        );
                        createWall(wallGeoHorizontal, wallPosition, true);
                    }

                    if (cell.walls.W) {
                        const wallPosition = new THREE.Vector3(
                            cellCenterX - cellW / 2 + halfWallT,
                            wallH / 2,
                            cellCenterZ
                        );
                        createWall(wallGeoVertical, wallPosition, false);
                    }
                }
            }

            const lastRowY = rows - 1;
            for (let x = 0; x < cols; x++) {
                if (grid[lastRowY][x].walls.S) {
                    const cellCenterX = x * cellW;
                    const cellCenterZ = lastRowY * cellH;
                    const wallPosition = new THREE.Vector3(
                        cellCenterX,
                        wallH / 2,
                        cellCenterZ + cellH / 2 - halfWallT
                    );
                    createWall(wallGeoHorizontal, wallPosition, true);
                }
            }

            const lastColX = cols - 1;
            for (let y = 0; y < rows; y++) {
                if (!(y === rows - 1 && !grid[y][lastColX].walls.E) && grid[y][lastColX].walls.E) {
                    const cellCenterX = lastColX * cellW;
                    const cellCenterZ = y * cellH;
                    const wallPosition = new THREE.Vector3(
                        cellCenterX + cellW / 2 - halfWallT,
                        wallH / 2,
                        cellCenterZ
                    );
                    createWall(wallGeoVertical, wallPosition, false);
                }
            }

            const exitX = (cols - 1) * cellW;
            const exitZ = (rows - 1) * cellH;
            const exitMat = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00aa00,
                roughness: 0.9,
                transparent: true,
                opacity: 0.6
            });
            const exitMarkerGeo = new THREE.PlaneGeometry(cellW * 0.8, cellH * 0.8);
            exitMarker = new THREE.Mesh(exitMarkerGeo, exitMat);
            exitMarker.rotation.x = -Math.PI / 2;
            exitMarker.position.set(exitX, 0.05, exitZ);
            exitMarker.receiveShadow = true;
            mazeGroup.add(exitMarker);

            return mazeGroup;
        }

        function createCrate(size = 1.5) {
            const crateGeo = new THREE.BoxGeometry(size, size, size);
            const crate = new THREE.Mesh(crateGeo, crateMat);
            crate.castShadow = true;
            crate.receiveShadow = true;
            return crate;
        }

        function createBarrel(height = 2, radius = 0.8) {
            const barrelGeo = new THREE.CylinderGeometry(radius, radius, height, 16);
            const barrel = new THREE.Mesh(barrelGeo, barrelMat);
            barrel.castShadow = true;
            barrel.receiveShadow = true;
            barrel.userData.type = 'decoration';
            return barrel;
        }

        function createCrystal(size = 1) {
            const crystalGeo = new THREE.IcosahedronGeometry(size, 0);
            const crystal = new THREE.Mesh(crystalGeo, crystalMat);
            crystal.castShadow = true;
            crystal.receiveShadow = true;
            return crystal;
        }

        function createRock(size = 1.5) {
            const detail = Math.random() < 0.5 ? 0 : 1;
            const rockGeo = new THREE.IcosahedronGeometry(size, detail);
            const positionAttribute = rockGeo.getAttribute('position');
            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                const z = positionAttribute.getZ(i);
                const warpFactor = 0.1 + Math.random() * 0.2;
                positionAttribute.setXYZ(
                    i,
                    x + (Math.random() - 0.5) * warpFactor * size,
                    y + (Math.random() - 0.5) * warpFactor * size,
                    z + (Math.random() - 0.5) * warpFactor * size
                );
            }
            rockGeo.computeVertexNormals();
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.castShadow = true;
            rock.receiveShadow = true;
            return rock;
        }

        function createPipeSegment(length = 2, radius = 0.3) {
            const pipeGeo = new THREE.CylinderGeometry(radius, radius, length, 12);
            const pipe = new THREE.Mesh(pipeGeo, pipeMat);
            pipe.castShadow = true;
            pipe.receiveShadow = true;
            return pipe;
        }

        function addDecorations(grid, cellW, cellH) {
            while (decorationGroup.children.length > 0) {
                decorationGroup.remove(decorationGroup.children[0]);
            }

            const rows = grid.length;
            const cols = grid[0].length;
            const decorationProbability = 0.15;

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if ((x === 0 && y === 0) || (x === cols - 1 && y === rows - 1)) {
                        continue;
                    }

                    if (Math.random() < decorationProbability) {
                        let decoration;
                        const type = Math.random();
                        const worldX = x * cellW;
                        const worldZ = y * cellH;

                        if (type < 0.25) {
                            decoration = createCrate(cellSize * 0.3 * (0.8 + Math.random() * 0.4));
                            decoration.position.set(worldX, decoration.geometry.parameters.height / 2 + 0.01, worldZ);
                        } else if (type < 0.5) {
                            decoration = createBarrel(cellSize * 0.4 * (0.8 + Math.random() * 0.4), cellSize * 0.15 * (0.8 + Math.random() * 0.4));
                            decoration.position.set(worldX, decoration.geometry.parameters.height / 2 + 0.01, worldZ);
                        } else if (type < 0.7) {
                            decoration = createCrystal(cellSize * 0.2 * (0.7 + Math.random() * 0.6));
                            decoration.position.set(worldX, decoration.geometry.parameters.radius * 0.8 + 0.01, worldZ);
                            decoration.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                        } else if (type < 0.9) {
                            decoration = createRock(cellSize * 0.25 * (0.8 + Math.random() * 0.5));
                            decoration.position.set(worldX, decoration.geometry.parameters.radius / 2 + 0.01, worldZ);
                            decoration.rotation.y = Math.random() * Math.PI * 2;
                        } else {
                            decoration = createPipeSegment(cellSize * 0.5 * (0.8 + Math.random() * 0.4), cellSize * 0.05);
                            decoration.position.set(worldX, decoration.geometry.parameters.radiusTop + 0.01, worldZ);
                            if (Math.random() < 0.5) {
                                decoration.rotation.z = Math.PI / 2;
                            } else {
                                decoration.rotation.x = Math.PI / 2;
                            }
                        }

                        decoration.rotation.y = Math.random() * Math.PI * 2;

                        decoration.position.x += (Math.random() - 0.5) * cellW * 0.1;
                        decoration.position.z += (Math.random() - 0.5) * cellH * 0.1;


                        decorationGroup.add(decoration);
                    }
                }
            }
        }

        function setupNewMaze() {
            if (mazeWallsGroup) scene.remove(mazeWallsGroup);
            obstacles = [];

            mazeGrid = generateMaze(mazeWidth, mazeHeight);
            mazeWallsGroup = createMazeGeometry(mazeGrid, cellSize, cellSize, wallHeight, wallThickness);
            scene.add(mazeWallsGroup);

            //addDecorations(mazeGrid, cellSize, cellSize);

            resetRobotPosition();
            isMoving = true;
            updateStatus(translations.statusNavigating, 'navigating');
            needsRotation = false;
            needsDecision = true;
            isWaitingForAPI = false;
            lastAPIAction = null;
            timeSinceLastAPICall = API_CALL_INTERVAL;
            updateApiStatus(translations.apiIdle, 'idle');

            const mazeCenterX = cellSize * (mazeWidth - 1) / 2;
            const mazeCenterZ = cellSize * (mazeHeight - 1) / 2;
            mainCamera.position.set(mazeCenterX, cellSize * mazeWidth * 0.9, mazeCenterZ + cellSize * mazeHeight * 0.6);
            mainCamera.lookAt(mazeCenterX, 0, mazeCenterZ);
            controls.target.set(mazeCenterX, 0, mazeCenterZ);

            topDownCamera.position.set(mazeCenterX, 150, mazeCenterZ);
            topDownCamera.rotation.order = 'YXZ';
            topDownCamera.rotation.x = -Math.PI / 2;
            topDownCamera.rotation.y = 0;
            topDownCamera.rotation.z = 0;

            onWindowResize();
        }

        function resetRobotPosition() {
            const startX = 0;
            const startZ = 0;

            const tempBox = new THREE.Box3().setFromObject(robotGroup);
            const robotHeight = tempBox.max.y - tempBox.min.y;
            const lowestPointRelativeY = tempBox.min.y - robotGroup.position.y;

            const desiredGroundClearance = 0.05;
            const robotWorldY = desiredGroundClearance - lowestPointRelativeY;


            robotGroup.position.set(startX, robotWorldY, startZ);
            robotGroup.rotation.y = Math.PI / 2;
            targetRotation = robotGroup.rotation.y;

            if (fpControls && fpControls.getObject()) {
                const cameraObject = fpControls.getObject();
                cameraObject.rotation.set(0, Math.PI, 0);
            }
        }


        function createBeautifulRobot() {
            const group = new THREE.Group();
            const shadowSetting = true;

            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x606070,
                metalness: 0.85,
                roughness: 0.4,
                envMapIntensity: 0.8
            });
            const accentMat = new THREE.MeshStandardMaterial({
                color: 0x404050,
                metalness: 0.7,
                roughness: 0.5
            });
            const jointMat = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                metalness: 0.9,
                roughness: 0.3
            });
            const headMat = new THREE.MeshStandardMaterial({
                color: 0x808090,
                metalness: 0.8,
                roughness: 0.35
            });
            const lensMat = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00aaaa,
                emissiveIntensity: 1.0,
                metalness: 0.1,
                roughness: 0.1,
                transparent: true,
                opacity: 0.8
            });
            const sensorMat = new THREE.MeshStandardMaterial({
                color: 0xff3333,
                emissive: 0xcc0000,
                emissiveIntensity: 1.2,
                metalness: 0.2,
                roughness: 0.4
            });
            const trackMat = new THREE.MeshStandardMaterial({
                color: 0x222222,
                metalness: 0.1,
                roughness: 0.8
            });
            const wheelMat = new THREE.MeshStandardMaterial({
                color: 0x444444,
                metalness: 0.6,
                roughness: 0.6
            });

            const baseHeight = 0.8;
            const trackWidth = 1.8;
            const trackLength = 3.5;
            const trackThickness = 0.7;
            const basePlatformWidth = 2.5;
            const basePlatformLength = 3.0;

            const baseGeo = new THREE.BoxGeometry(basePlatformWidth, baseHeight, basePlatformLength);
            const base = new THREE.Mesh(baseGeo, bodyMat);
            base.position.y = trackThickness / 2 + baseHeight / 2;
            group.add(base);

            const trackGeo = new THREE.BoxGeometry(trackWidth, trackThickness, trackLength);
            const leftTrack = new THREE.Mesh(trackGeo, trackMat);
            leftTrack.position.set(-(basePlatformWidth / 2 + trackWidth / 2) * 0.8, trackThickness / 2, 0);
            group.add(leftTrack);

            const rightTrack = new THREE.Mesh(trackGeo, trackMat);
            rightTrack.position.set((basePlatformWidth / 2 + trackWidth / 2) * 0.8, trackThickness / 2, 0);
            group.add(rightTrack);

            const wheelRadius = trackThickness * 0.4;
            const wheelDepth = trackWidth * 0.8;
            const wheelGeo = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelDepth, 16);
            const numWheels = 3;
            for (let i = 0; i < numWheels; i++) {
                const zPos = (i - (numWheels - 1) / 2) * (trackLength * 0.6 / (numWheels - 1 || 1));

                const leftWheel = new THREE.Mesh(wheelGeo, wheelMat);
                leftWheel.rotation.z = Math.PI / 2;
                leftWheel.position.set(leftTrack.position.x, wheelRadius, zPos);
                group.add(leftWheel);

                const rightWheel = new THREE.Mesh(wheelGeo, wheelMat);
                rightWheel.rotation.z = Math.PI / 2;
                rightWheel.position.set(rightTrack.position.x, wheelRadius, zPos);
                group.add(rightWheel);
            }

            const torsoHeight = 3.0;
            const torsoRadius = 1.2;
            const torsoYOffset = base.position.y + baseHeight / 2 + torsoHeight / 2 + 0.1;

            const torsoGeo = new THREE.CylinderGeometry(torsoRadius, torsoRadius * 0.9, torsoHeight, 20);
            const torso = new THREE.Mesh(torsoGeo, bodyMat);
            torso.position.y = torsoYOffset;
            group.add(torso);

            const plateGeo = new THREE.BoxGeometry(torsoRadius * 1.5, torsoHeight * 0.6, 0.15);
            const frontPlate = new THREE.Mesh(plateGeo, accentMat);
            frontPlate.position.set(0, torsoYOffset, torsoRadius * 0.95);
            group.add(frontPlate);

            const backPlate = new THREE.Mesh(plateGeo, accentMat);
            backPlate.position.set(0, torsoYOffset, -torsoRadius * 0.95);
            group.add(backPlate);


            const headSize = 1.5;
            const headYOffset = torsoYOffset + torsoHeight / 2 + headSize * 0.4;

            const headGeo = new THREE.BoxGeometry(headSize, headSize * 0.8, headSize * 0.9);
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = headYOffset;
            group.add(head);

            const neckRadius = 0.5;
            const neckHeight = 0.5;
            const neckGeo = new THREE.CylinderGeometry(neckRadius, neckRadius, neckHeight, 16);
            const neck = new THREE.Mesh(neckGeo, jointMat);
            neck.position.y = torsoYOffset + torsoHeight / 2 + neckHeight / 2;
            group.add(neck);


            const lensRadius = headSize * 0.3;
            const lensLength = 0.3;
            const lensGeo = new THREE.CylinderGeometry(lensRadius, lensRadius, lensLength, 20);
            const mainLens = new THREE.Mesh(lensGeo, lensMat);
            mainLens.rotation.x = Math.PI / 2;
            mainLens.position.set(0, headYOffset, headSize * 0.45 + lensLength / 2);
            group.add(mainLens);

            const sensorRadius = 0.15;
            const sensorGeo = new THREE.SphereGeometry(sensorRadius, 16, 8);
            const sensorLight = new THREE.Mesh(sensorGeo, sensorMat);
            sensorLight.position.set(headSize * 0.35, headYOffset + headSize * 0.25, headSize * 0.45);
            group.add(sensorLight);

            const antennaBaseRadius = 0.15;
            const antennaBaseHeight = 0.4;
            const antennaPoleRadius = 0.05;
            const antennaPoleHeight = 1.8;
            const antennaYOffset = headYOffset + headSize * 0.4;

            const antennaBaseGeo = new THREE.CylinderGeometry(antennaBaseRadius, antennaBaseRadius * 0.8, antennaBaseHeight, 8);
            const antennaBase = new THREE.Mesh(antennaBaseGeo, accentMat);
            antennaBase.position.set(-headSize * 0.35, antennaYOffset + antennaBaseHeight / 2, -headSize * 0.2);
            group.add(antennaBase);

            const antennaPoleGeo = new THREE.CylinderGeometry(antennaPoleRadius, antennaPoleRadius * 0.8, antennaPoleHeight, 6);
            const antennaPole = new THREE.Mesh(antennaPoleGeo, jointMat);
            antennaPole.position.set(antennaBase.position.x, antennaYOffset + antennaBaseHeight + antennaPoleHeight / 2, antennaBase.position.z);
            group.add(antennaPole);

            const shoulderY = torsoYOffset + torsoHeight * 0.3;
            const shoulderX = torsoRadius * 1.0;
            const shoulderRadius = 0.4;
            const upperArmLength = 1.5;
            const armRadius = 0.25;

            const shoulderGeo = new THREE.SphereGeometry(shoulderRadius, 16, 8);
            const leftShoulder = new THREE.Mesh(shoulderGeo, jointMat);
            leftShoulder.position.set(-shoulderX, shoulderY, 0);
            group.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(shoulderGeo, jointMat);
            rightShoulder.position.set(shoulderX, shoulderY, 0);
            group.add(rightShoulder);

            const upperArmGeo = new THREE.CylinderGeometry(armRadius, armRadius * 0.9, upperArmLength, 12);
            const leftUpperArm = new THREE.Mesh(upperArmGeo, bodyMat);
            leftUpperArm.position.set(-shoulderX, shoulderY - upperArmLength / 2 - shoulderRadius * 0.5, 0);
            leftUpperArm.rotation.z = Math.PI / 16;
            group.add(leftUpperArm);

            const rightUpperArm = new THREE.Mesh(upperArmGeo, bodyMat);
            rightUpperArm.position.set(shoulderX, shoulderY - upperArmLength / 2 - shoulderRadius * 0.5, 0);
            rightUpperArm.rotation.z = -Math.PI / 16;
            group.add(rightUpperArm);

            group.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = shadowSetting;
                    child.receiveShadow = shadowSetting;
                }
            });


            return group;
        }

        function updateStatus(text, className) {
            statusElement.textContent = text;
            statusElement.className = className;
        }

        function updateApiStatus(text, className) {
            apiStatusElement.textContent = text;
            apiStatusElement.className = className;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (controls.enabled) {
                controls.update();
            } else if (flyControls.enabled) {
                flyControls.update(delta);
            }
            timeSinceLastAPICall += delta;

            if (isMoving) {
                updateNavigationSensors();

                if (needsDecision && !isWaitingForAPI && timeSinceLastAPICall >= API_CALL_INTERVAL) {
                    callAPIForDecision();
                }

                if (!needsRotation && lastAPIAction) {
                    const actionToPerform = lastAPIAction;
                    lastAPIAction = null;

                    switch (actionToPerform) {
                        case translations.apiActionLeft:
                            initiateTurn(-Math.PI / 2);
                            updateApiStatus(`${translations.apiReceived} ${translations.uiActionLeft}`, 'received');
                            break;
                        case translations.apiActionRight:
                            initiateTurn(Math.PI / 2);
                            updateApiStatus(`${translations.apiReceived} ${translations.uiActionRight}`, 'received');
                            break;
                        case translations.apiActionForward:
                            updateApiStatus(`${translations.apiReceived} ${translations.uiActionForward}`, 'received');
                            break;
                        default:
                            console.warn("Неожиданное действие от API, поворот НАЛЕВО:", actionToPerform);
                            initiateTurn(-Math.PI / 2);
                            updateApiStatus(`${translations.apiError} Неверное действие`, 'error');
                            break;
                    }
                }

                if (needsRotation) {
                    const rotationDifference = normalizeAngle(targetRotation - robotGroup.rotation.y);
                    const rotationStep = Math.sign(rotationDifference) * turnSpeed * delta;

                    if (Math.abs(rotationDifference) <= Math.abs(rotationStep)) {
                        robotGroup.rotation.y = targetRotation;
                        needsRotation = false;
                        needsDecision = true;
                        if (!isWaitingForAPI) updateApiStatus(translations.apiIdle, 'idle');
                    } else {
                        robotGroup.rotation.y += rotationStep;
                        robotGroup.rotation.y = normalizeAngle(robotGroup.rotation.y);
                    }
                }
                else if (!isWaitingForAPI && !needsDecision) {
                    if (frontSensorDist > collisionThreshold) {
                        const moveDistance = moveSpeed * delta;
                        const direction = new THREE.Vector3();
                        robotGroup.getWorldDirection(direction);
                        robotGroup.position.addScaledVector(direction, moveDistance);

                        const exitX = (mazeWidth - 1) * cellSize;
                        const exitZ = (mazeHeight - 1) * cellSize;
                        const exitThreshold = cellSize * 0.4;
                        if (Math.abs(robotGroup.position.x - exitX) < exitThreshold &&
                            Math.abs(robotGroup.position.z - exitZ) < exitThreshold) {
                            isMoving = false;
                            updateStatus(translations.statusSolved, 'solved');
                            updateApiStatus(translations.apiComplete, 'received');
                        }
                    } else {
                        needsDecision = true;
                        if (!isWaitingForAPI) updateApiStatus(translations.apiIdle, 'idle');
                    }
                }

            }

            if (compassNeedleElement && compassRoseElement) {
                const cameraForward = new THREE.Vector3();
                let currentCamera;

                switch (activeCameraType) {
                    case 'firstPerson':
                        currentCamera = firstPersonCamera;
                        break;
                    case 'free':
                        currentCamera = freeCamera;
                        break;
                    case 'main':
                    default:
                        currentCamera = mainCamera;
                        break;
                }

                currentCamera.getWorldDirection(cameraForward);
                cameraForward.y = 0;

                let cameraHeadingRad = 0;
                if (cameraForward.lengthSq() > 0.0001) {
                    cameraForward.normalize();
                    cameraHeadingRad = Math.atan2(cameraForward.x, cameraForward.z);
                }

                const needleRotationDeg = -cameraHeadingRad * (180 / Math.PI);

                compassNeedleElement.style.transform = `rotate(${needleRotationDeg}deg)`;

                compassRoseElement.style.transform = `rotate(45deg)`;
            }

            const fStr = frontSensorDist === Infinity ? translations.debugInfinity : frontSensorDist.toFixed(1);
            const lStr = leftSensorDist === Infinity ? translations.debugInfinity : leftSensorDist.toFixed(1);
            const rStr = rightSensorDist === Infinity ? translations.debugInfinity : rightSensorDist.toFixed(1);
            const sensorValuesElement = document.getElementById('sensor-values');
            if (sensorValuesElement) {
                sensorValuesElement.innerHTML =
                    `<span class="sensor-reading">${translations.debugSensorPrefixF} ${fStr}</span>` +
                    `<span class="separator">|</span>` +
                    `<span class="sensor-reading">${translations.debugSensorPrefixL} ${lStr}</span>` +
                    `<span class="separator">|</span>` +
                    `<span class="sensor-reading">${translations.debugSensorPrefixR} ${rStr}</span>`;
            }

            let currentCamera;
            switch (activeCameraType) {
                case 'firstPerson':
                    currentCamera = firstPersonCamera;
                    break;
                case 'free':
                    currentCamera = freeCamera;
                    break;
                case 'main':
                default:
                    currentCamera = mainCamera;
                    break;
            }

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.render(scene, currentCamera);

            const worldBounds = Math.max(mazeWidth, mazeHeight) * cellSize * 1.5;
            if (Math.abs(robotGroup.position.x) > worldBounds || Math.abs(robotGroup.position.z) > worldBounds || robotGroup.position.y < -5 || robotGroup.position.y > 50) {
                console.warn(`Робот вышел за пределы мира (${robotGroup.position.x.toFixed(1)}, ${robotGroup.position.y.toFixed(1)}, ${robotGroup.position.z.toFixed(1)}), перезапускаем лабиринт.`);
                setupNewMaze();
            }
        }

        function updateNavigationSensors() {
            const robotPos = robotGroup.position.clone();
            const sensorVerticalOffset = robotGroup.scale.y * 1.5;
            robotPos.y += sensorVerticalOffset;

            const forwardOffsetDistance = robotGroup.scale.z * 1.0;
            const directionVec = new THREE.Vector3();
            robotGroup.getWorldDirection(directionVec);
            const sensorOrigin = robotPos.clone().addScaledVector(directionVec, forwardOffsetDistance);


            const forwardDir = new THREE.Vector3();
            robotGroup.getWorldDirection(forwardDir);

            const rightDir = new THREE.Vector3().crossVectors(robotGroup.up, forwardDir).normalize();
            const leftDir = rightDir.clone().negate();

            const raycastables = [...obstacles, ...decorationGroup.children];

            navigationRaycaster.far = sensorDistance;

            navigationRaycaster.set(sensorOrigin, forwardDir);
            const frontIntersects = navigationRaycaster.intersectObjects(raycastables);
            frontSensorDist = frontIntersects.length > 0 ? frontIntersects[0].distance : Infinity;

            navigationRaycaster.set(sensorOrigin, rightDir);
            const rightIntersects = navigationRaycaster.intersectObjects(raycastables);
            rightSensorDist = rightIntersects.length > 0 ? rightIntersects[0].distance : Infinity;

            navigationRaycaster.set(sensorOrigin, leftDir);
            const leftIntersects = navigationRaycaster.intersectObjects(raycastables);
            leftSensorDist = leftIntersects.length > 0 ? leftIntersects[0].distance : Infinity;
        }


        function initiateTurn(angleDelta) {
            if (needsRotation) return;
            targetRotation = normalizeAngle(robotGroup.rotation.y + angleDelta);
            needsRotation = true;
            needsDecision = false;
            lastAPIAction = null;
        }

        function normalizeAngle(angle) {
            while (angle <= -Math.PI) angle += Math.PI * 2;
            while (angle > Math.PI) angle -= Math.PI * 2;
            return angle;
        }

        async function callAPIForDecision() {
            isWaitingForAPI = true;
            needsDecision = false;
            updateApiStatus(translations.apiRequesting, 'requesting');

            const fDistStr = frontSensorDist === Infinity ? "Infinity" : frontSensorDist.toFixed(1);
            const lDistStr = leftSensorDist === Infinity ? "Infinity" : leftSensorDist.toFixed(1);
            const rDistStr = rightSensorDist === Infinity ? "Infinity" : rightSensorDist.toFixed(1);
            const clearThreshold = cellSize * 0.9;
            const isFrontClear = frontSensorDist > clearThreshold;
            const isLeftClear = leftSensorDist > clearThreshold;
            const isRightClear = rightSensorDist > clearThreshold;

            const API_URL = 'https://mrdenygrom.pythonanywhere.com/api/gemini';

            const prompt = `You are the AI controller for a robot in a 3D maze simulation.
    Goal: Navigate the robot from the start (near 0,0) to the exit (near positive X and Z corner).
    Current Sensor Readings:
    - Distance to obstacle in Front (F): ${fDistStr} units.
    - Distance to obstacle on Left (L): ${lDistStr} units.
    - Distance to obstacle on Right (R): ${rDistStr} units.
    (A distance > ${clearThreshold.toFixed(1)} generally means the path is clear in that direction for at least one cell).

    Based ONLY on these sensor readings, decide the IMMEDIATE next action for the robot to eventually reach the exit.
    Your response MUST be a single word: FORWARD, LEFT, or RIGHT. Try to explore and avoid getting stuck in loops. Prioritize clear paths. If multiple paths are clear, maybe prioritize RIGHT or FORWARD. If only front is blocked, turn LEFT or RIGHT. If all are blocked, turn LEFT (or RIGHT).

    Example: If F=1.2, L=10.5, R=1.1, you should choose LEFT.
    Example: If F=10.0, L=1.0, R=12.0, you might choose FORWARD or RIGHT.

    Current readings: F=${fDistStr}, L=${lDistStr}, R=${rDistStr}.
    Is Front clear? ${isFrontClear}. Is Left clear? ${isLeftClear}. Is Right clear? ${isRightClear}.

    Your action (FORWARD, LEFT, or RIGHT):`;

            const requestData = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    temperature: 0.4,
                    maxOutputTokens: 10,
                    topP: 0.9,
                }
            };

            try {
                const response = await fetch(API_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(requestData)
                });

                let data;
                try {
                    data = await response.json();

                } catch (jsonError) {

                    const textResponse = await response.text();

                    throw new Error(`API request failed with status ${response.status} and non-JSON response.`);
                }


                if (!response.ok) {
                    const errorMessage = data?.error?.message || `Status ${response.status}`;

                    throw new Error(`API request failed: ${errorMessage}`);
                }

                if (data.error) {

                    throw new Error(`API Error: ${data.error.message || 'Unknown API error'}`);
                }

                let apiResultText = null;
                if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                    apiResultText = data.candidates[0].content.parts[0].text.trim().toUpperCase();
                } else {
                    throw new Error("Invalid API response structure: Cannot find result text.");
                }


                if (apiResultText.includes(translations.apiActionForward)) {
                    lastAPIAction = translations.apiActionForward;
                } else if (apiResultText.includes(translations.apiActionLeft)) {
                    lastAPIAction = translations.apiActionLeft;
                } else if (apiResultText.includes(translations.apiActionRight)) {
                    lastAPIAction = translations.apiActionRight;
                } else {

                    throw new Error(`Invalid API response content: ${apiResultText.substring(0, 50)}...`);
                }

            } catch (error) {
                updateApiStatus(`${translations.apiError} ${error.message}`, 'error');
                lastAPIAction = translations.apiActionLeft;
            } finally {
                isWaitingForAPI = false;
                timeSinceLastAPICall = 0;
            }
        }


        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = width / height;

            mainCamera.aspect = aspect;
            mainCamera.updateProjectionMatrix();

            const orthoSize = Math.max(mazeWidth, mazeHeight) * cellSize * 0.6;
            topDownCamera.left = -orthoSize * aspect;
            topDownCamera.right = orthoSize * aspect;
            topDownCamera.top = orthoSize;
            topDownCamera.bottom = -orthoSize;
            topDownCamera.updateProjectionMatrix();

            firstPersonCamera.aspect = aspect;
            firstPersonCamera.updateProjectionMatrix();

            freeCamera.aspect = aspect;
            freeCamera.updateProjectionMatrix();

            renderer.setSize(width, height);
        }

        init();

    </script>

</body>

</html>
